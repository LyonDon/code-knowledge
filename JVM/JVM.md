
![性能调优.jpg](.\性能调优.jpg)

![jvm和性能优化.jpg](.\jvm和性能优化.jpg)

[一、java内存区域与内存溢出异常](#1)

[1.1 JVM内存结构 vs Java内存模型 vs Java对象模型](#1.1)
[1.1.1 JVM内存结构](#1.1.1)
[1.1.2 JVM内存模型](#1.1.2)
[1.1.1 JVM对象模型](#1.1.3)

[1.2 类加载系统(Class Loader SubSystem)](#1.2)
[1.2.1 加载](#1.2.1)
[1.2.1 链接](#1.2.2)
[1.2.1 初始化](#1.2.3)

[1.3 运行时数据区](#1.3)
[1.3.1 方法区（JVM共享）](#1.3.1)
[1.3.2 堆区（JVM共享）](#1.3.2)
[1.3.3 栈区（java虚拟机栈）](#1.3.3)
[1.3.4 PC寄存器区](#1.3.4)
[1.3.5 本地方法栈区](#1.3.5)

[1.4 执行引擎](#1.4)
[1.4.1字节码文件](#1.4.1)

[1.5 OutOfMemory异常](#1.5)
[1.5.1 Java堆溢出](#1.5.1)
[1.5.2 虚拟机栈和本地方法栈溢出](#1.5.2)
[1.5.3 方法区和运行时常量池溢出](#1.5.3)
[1.5.4 本机直接内存溢出](#1.5.4)

[二、GC与内存分配策略](#2)


[2.1 GC基本方式](#2.1)
[2.1.1 标记清除](#2.1.1)
[2.1.2 复制收集](#2.1.2)
[2.1.3 引用计数](#2.1.3)
[2.1.4 分代收集算法（广泛使用）](#2.1.4)
[2.1.5 可达性分析算法](#2.1.5)
[2.1.6 引用](#2.1.6)

[2.2 垃圾收集器](#2.2)
[2.2.1 GMS](#2.2.1)
[2.2.2 G1收集器](#2.2.2)

[2.3 回收方法区](#2.3)

[2.4 对象](#2.4)
[2.4.1 对象的创建](#2.4.1)
[2.4.2 对象的内存布局](#2.4.2)
[2.4.3 对象的访问定位](#2.4.3)

[2.5 HotSpot算法实现](#2.5.1)

[2.6 其他](#2.6)
[2.6.1 MinorGC和MajorGC](#2.6.1)
[2.6.2 长期存活的对象进入老年代](#2.6.2)
[2.6.3 动态对象年龄判断](#2.6.3)

[三、虚拟机性能与故障处理工具](#3)

[3.1 JDK命令行工具](#3.1)
[3.2 JDK可视化工具](#3.2)

[四、调优案例分析与实战](#4)

[4.1 实例](#4.1)
[4.1.1 高性能上的硬件部署策略](#4.1.1)

[4.1.1.1 1.通过64位JDK来使用大内粗](#4.1.1.1)
[4.1.1.2 2.使用若干个32位虚拟机建立逻辑集群来利用硬件资源](#4.1.1.2)

[4.1.2 集群间同步导致内存溢出](#4.1.2)
[4.1.3 堆外内存导致的溢出错误](#4.1.3)
[4.1.4 外部命令导致系统变慢](#4.1.4)
[4.1.5 不恰当数据结构导致内存占用过大](#4.1.5)
[4.1.6 由windows虚拟内存导致的长时间停顿](#4.1.6)

[五、类文件结构](#5)

[5.2 无关性的基石](#5.2)
[5.3 Class类文件结构](#5.3)

[5.3.1 魔数与Class文件版本](#5.3.1)
[5.3.2 常量池](#5.3.2)
[5.3.3 访问标志](#5.3.3)
[5.3.4 类索引，父类索引和接口索引集合](#5.3.4)
[5.3.5 字段表集合](#5.3.5)
[5.3.6 方法表集合](#5.3.6)
[5.3.7 属性表集合](#5.3.7)

[5.4 字节码指令](#5.4)
[5.4.1 字节码与数据类型](#5.4.1)

[5.5 共有设计和私有实现](#5.5)

[5.6 Class文件结构的发展](#5.6)

[六、虚拟机类加载机制](#6)

[6.1 类加载的时机](#6.1)

[6.2 类加载的过程](#6.2)
[6.2.1 1.加载](#6.2.1)
[6.2.2 2.验证](#6.2.2)
[6.2.3 3.准备](#6.2.3)
[6.2.4 4.解析](#6.2.4)
[6.2.5 5.初始化](#6.2.5)

[6.3 类加载器](#6.3)
[6.3.1 类与类加载器](#6.3.1)
[6.3.2 双亲委派模型](#6.3.2)
[6.3.3 破坏双亲委派模型](#6.3.3)


[七、虚拟机字节码执行引擎](#7)

[7.1 类加载器](#6.3)
[7.1.1 局部变量表](#7.1.1)
[7.1.2 操作数栈](#7.1.2)
[7.1.3 动态链接](#7.1.3)
[7.1.4 方法返回地址](#7.1.4)
[7.1.5 附加信息](#7.1.5)

<h1 id='1'>Java内存区域与内存溢出异常</h1>

<h2 id='1.1'>JVM内存结构 vs Java内存模型 vs Java对象模型</h2>

<h3 id='1.1.1'> JVM内存结构</h3>

与JVM运行时内存有关，虚拟机会在java程序执行过程中将其所管理的内存分为不同的区域，分别负责不同的功能

*	上层：PC寄存器、java虚拟机栈、本地方法栈
*	中层：Java堆、运行时常量池
*	下层：线程内存区域、运行时常量

![1554085192.png](.\1554085192.png)

<h3 id='1.1.2'> JVM内存模型</h3>

JMM，主要围绕多线程中出现的原子性，可见性，顺序性等问题及多线程通信的相关特性而建立的模型。Java线程间通信是通过共享内存实现的

*	原子性对应的是处理器优化
*	顺序性对应的是指令重排序
*	可见性对应的是缓存一致性问题

![1554085095.png](.\1554085095.png)

<h3 id='1.1.3'> JVM对象模型</h3>

主要表示的是java对象在JVM中的存储结构

***


<h2 id='1.2'>类加载系统(Class Loader SubSystem)</h2>

<h3 id='1.2.1'>加载</h3>

1.	Boot Strap class Loader：加载系统引导类
2.	Extension class Loader：加载拓展类
3.	Application class Loader：加载应用层级类

<h3 id='1.2.2'>链接</h3>

1.	Verify：验证字节码是否正确
2.	Prepare：分配静态变量并设置默认值
3.	Resolve：符号引用被替换为指向方法区的原始引用

<h3 id='1.2.3'>初始化</h3>

**类加载的最后一步，所有静态变量都会被赋值，从父类到子类执行**


<h2 id='1.3'>运行时数据区</h2>

<h3 id='1.3.1'>方法区（ JVM 共享）</h3>

*保存类，成员信息，父类和接口信息，运行时常量池*

与 java 堆一样，是各个线程共享的内存区域，主要用于对于常量池的内存回收和对类的卸载，如果方法区溢出，则会抛出 outOfMemoryError

>由 java 虚拟机自带的类加载器所加载的类，始终不会被卸载。用户自定义的类加载器所加载的类可能会被卸载。类的卸载是指被 GC 回收

<h3 id='1.3.2'>堆区（ JVM 共享）</h3>

*保存所有对象信息*

在虚拟机启动时创建，为所有线程所共享，所有的对象实例和数组都要在堆上分配

<h3 id='1.3.3'>栈区（ java 虚拟机栈）</h3>

*每个线程的栈*

与PC寄存器一样，虚拟机栈是线程私有的，每一个方法从调用到执行完成的过程，就对应着栈帧在虚拟机中的入栈和出栈过程，为虚拟机执行 java 方法服务

<h3 id='1.3.4'>PC 寄存器区</h3>

*保存当前指令地址，若执行的是本地方法，则 PC 为 null*

一块较小的内存区域，可以看做是当前线程执行字节码的行号指示器

<h3 id='1.3.5'>本地方法栈区</h3>

*与栈区相似，只是保存的是本地方法*

具体的虚拟机可以自由实现本地方法栈区

<h2 id='1.4'>执行引擎</h2>

*	字节码解释器	可以执行字节码

*	模板解释器	直接将对应的指令集转换为本地代码

*	JIT编译器	优化代码

*	垃圾收集器	回收不用的内存和对象

*	Java Native Interface	简称JNI，暴露本地方法接口，使得java程序可以执行本地方法

*	Native Method Libraries	本地方法库

<h3 id='1.4.1'>字节码文件</h3>

字节码文件就是java源文件经过编译之后形成的.class文件，用于JVM进行处理。每一个字节码文件对应一个class或者interface的定义信息，即便一个java文件中定义了多个class或者interface，其对应的.class文件表示的是它们的全部

***

<h2 id='1.5'>OutOfMemory异常</h2>

<h3 id='1.5.1'>Java堆溢出</h3>

java堆内存中的OOM异常实际上就是常见的内存溢出异常

*	处理java堆内存问题:

	1.	通过内存映像分析工具对dump出来的堆转储快照进行分析,确认内存中的对象是否是必要的

	2.	区分是内存泄漏还是内存溢出
		-	内存泄漏
			查看GCRoots的引用链

    	-	否则,检查虚拟机的堆参数

<h3 id='1.5.2'>虚拟机栈和本地方法栈溢出</h3>

*	java虚拟机描述了两种异常

	-	当线程申请的栈深度大于虚拟机所允许的最大栈深度,报StackOverflowError

	-	当虚拟机在扩展栈时无法申请到足够的空间时,报OutOfMemoryError

**然而,实验表明,在单个线程下,无论是栈帧太大还是虚拟机栈容量太小,当内存无法分配时,都会报出StackOverflowError**

>栈帧就是存储在用户栈或者内核栈上的每次函数调用的记录单元

*	可以通过建立多线程导致内存溢出.然而,在无法更换内存地址的情况下,只能通过减少最大栈和减少栈容量来换取更多的线程

<h3 id='1.5.3'>方法区和运行时常量池溢出</h3>

*	比较常见,一个类要被垃圾回收器回收掉,判定条件是比较苛刻的.在大量动态生成class类文件的应用中,需要特别注意类的回收情况

<h3 id='1.5.4'>本机直接内存溢出</h3>

*	虽然可以使用DirectMemory指定分配内存（不指定的话默认是java堆的最大内存），但是DirectMemory实际上没有分配内存，而是通过计算得知无法获得足够内存。这时就可以使用Unsafe类

>Java本来被设计为一种安全的受控环境,但是,还是存在一个后门.提供了一些可以直接操作线程和内存的低层次环境,这个后门类叫做unsafe。极不建议使用，因为对于内存的直接操作可能会造成不可预知的后果

***

<h1 id='2'>GC与内存分配策略</h1>

<h2 id='2.1'>GC基本方式</h2>

<h3 id='2.1.1'>标记清除</h3>

*	为引用的对象设置标记。通过两次查找实现，第一次从根部开始，类似树的遍历过程一样，对每个引用的对象设置标记。第二次继续从根部开始，查找全部对象，对于没有标记的对象直接释放其所持有的内存
	
	+	优点：好理解
    +	缺点：如果被引用的对象占所有对象的比例比较小，则需要遍历全部对象，系统消耗较大

<h3 id='2.1.2'>复制收集</h3>

*	试图解决标记清除带来的问题。另外开辟一块空间，遍历一次，将被引用的对象根据其引用关系存储在新开辟的空间中。然后直接将原空间当做垃圾回收
	
	+	优点：一定程度上减少了系统开销，对于引用对象比例较低的情况比较适用；同时还有局部性的好处，即相互引用的对象其存储位置也会比较接近，这样提高了访问速度
    +	缺点：对于引用对象比例较高的情况，开辟新的内存空间会比较消耗内存，提高开销

<h3 id='2.1.3'>引用计数</h3>

*	对于所有对象，按照其被引用的次数进行计数。当引用失效时，就实时减少其对应的引用数；反之亦然。

	+	优点：实现更加容易；更动态，细粒度；由于释放机制是针对个别来实现的，所以中断由GC产生的中断时间更短
    +	缺点：无法应对循环引用；依赖于计数，如果计数出现错误，则很难发现；多线程情况下可能会出现一致性问题（由于这一点的存在，java的实现上没有采用这种方法）

<h3 id='2.1.4'>分代收集算法（现在的多说虚拟机采用方式）</h3>

*	根据对象存活周期将java堆分为新生代和老年代

	*	新生代中的对象存活时间短，采用复制收集算法
	*	老年代中的对象存活时间长，采用标记清除算法

<h3 id='2.1.5'>可达性分析算法</h3>

*	java中使用的是这种方式，类似于标记清除算法（只是通过的是引用链）

*	可作为GCRoots对象的包括以下几种：

    *	虚拟机栈中引用的对象
    *	方法区中静态属性引用的对象
    *	方法区中常量引用的对象
    *	本地方法栈中JNI（即一般说的Native方法）引用的对象

<h3 id='2.1.6'>引用</h3>

上面这几种方式，都使用了引用的概念。java种的引用分为以下几种：

*	强引用
	*	就是类似`Object obj=new Object()`这样的引用，只要引用存在，GC就不能回收

*	软引用
	*	描述一些有用但非必须的对象

*	弱引用
	*	描述非必须对象，其存活时间只维持到下一次的GC之前

*	虚引用
	*	最弱的引用关系，只是为了在对象被回收的时候能够返回一个通知


<h2 id='2.2'>垃圾收集器</h2>

**三种垃圾收集器**

*	串行收集器：单线程，适用数据量较小的情况
*	并行收集器：对吞吐量有要求的大中型应用，响应时间可能比较ch
*	并发收集器：对响应速度有要求的大中型应用

*	新生代
	*	Serial，parallel Scavenge（吞吐量），ParNew

*	老年代
	*	Serial Old，Parallel Old，CMS

*	新生代+老年代
	*	G1

<h3 id='2.2.1'>CMS</h3>

**步骤：**

1.	初始标记
2.	并发标记
3.	重新标记
4.	清除并发

**是一种 标记-清除 垃圾收集器**

*	由于其可以与用户线程并发执行，所以是一种并发，低停顿的垃圾收集器

*	比较适用于对响应速度要求较高的情况

**存在三个比较明显的缺点：**

*	对CPU资源非常敏感

*	无法处理浮动垃圾

*	“标记-清除”算法容易产生大量的空间碎片

<h3 id='2.2.2'>G1收集器</h3>

步骤：

1.	初始标记
2.	并发标记
3.	最终标记
4.	筛选回收

**最前沿的垃圾收集器**

*	并行与并发
*	分代收集
*	空间整合

>区别于CMS的“标记-清除”算法，G1是“标记-整理”算法，不会产生大量的空间碎片

*	可预测的停顿

***

**Java的内存管理总结起来就两个方面**

*	给对象的内存分配
*	回收分配给对象的内存

<h2 id='2.3'>回收方法区</h2>

**方法区的垃圾回收相比于堆区而言，效率很低。这也是很多人认为方法区不存在垃圾回收的原因**

*	永久代的垃圾回收

	*	废弃常量
	*	无用的类

>永久代是HotSpot虚拟机特有的概念，是方法区的一种实现。在java8中被取消，取而代之的是元空间

<h2 id='2.4'>对象</h2>

<h3 id='2.4.1'>对象的创建</h3>

~~~mermaid
graph TD

类加载检查-->为新生对象分配内存
为新生对象分配内存-->指针碰撞
为新生对象分配内存-->空闲列表

类加载检查-->安全性考虑
安全性考虑-->CAS失败重试
安全性考虑-->内存分配按照线程划分到不同空间

为新生对象分配内存-->内存空间初始化为0
内存空间初始化为0-->对对象进行必要设置
~~~


<h3 id='2.4.2'>对象的内存布局</h3>

-	对象头
-	实例数据
-	对齐填充

<h3 id='2.4.3'>对象的访问定位</h3>

由于对象在虚拟机栈中只保存了一个指针的引用，所以对于对象的访问方式取决于虚拟机的具体实现，两种方式：

*	句柄：更稳定，不需要修改reference
*	直接指针，速度更快，省去了到对象实例数据的指针，省去了一次指针定位的时间


<h2 id='2.5'>HotSpot算法实现</h2>

*GC执行时必须停止所有java执行线程，因为对象间的引用关系不能在GC的时候发生更改*

**安全点的设置**

基于上一点，需要设置安全点，使得系统在安全点上才进行GC

安全点的设置时间不能太长也不能太短。基本上以下面的标准进行选定：
>是否具有让程序长时间执行的特征

安全点是通过轮询CPU中断来实现的，与轮询中断标志为真的时间相重合

***



<h2 id='2.6'>其他</h2>

<h3 id='2.6.1'>MinorGC和MajorGC</h3>

*	MinorGC（新生代GC）：指的是在新生代发生的垃圾收集算法，比较频繁，速度较快

*	MajorGC（老年代GC）：指的是在老年代发生的垃圾收集算法，比MinorGC的速度慢十倍以上

<h3 id='2.6.2'>长期存活的对象将进入老年代</h3>

>若对象在Eden区出生，经过一次MinorGC依然存活，且能够被Survivor区容纳则将其放入Survivor区,并将其**年龄计数器**置为1。在这之后，每经过一次MinorGC，计数器加一，当年龄计数器的值为MaxTenuringThreshold（一般为15）时，将对象放入老年代

<h3 id='2.6.3'>动态对象年龄判定</h3>

虚拟机并不是强制要求需要大于MaxTenuringThreshold的值才放入老年代，而是当超过半数的对象处于相同年龄，大于这个年龄的对象就能放入老年代

*只要老年代剩余空间大小大于新生代总空间大小或者历次晋升的平均空间大小就会进行MinorGC*

***

<h1 id='3'>虚拟机性能监控与故障处理工具</h1>

<h2 id='3.1'>JDK命令行工具</h2>

*	jps:可以列出

	+	正在执行的虚拟机进程
	+	其唯一的进程ID
	+	主类所在的类名

*	jstat：监视虚拟机的各种运行状态

	*	jstat工具主要选项：

		选项|作用
:--:|:--:
-class|监视器装载，卸载数量等
-gc|监视java堆使用情况，包括Eden区，两个survivor区，老年代，永久代等，以及GC时间
-gccapacity|同上，输出主要关注java堆的使用情况
-gcutil|同上，输出主要关注已使用空间占总空间的百分比
-gccause|同上，输出主要关注引起变化的原因
-gcnew|监视新生代GC情况
-gcnewcapacity|监视新生代已使用的最大最小空间
-gcold|监视老年代GC情况
-gcoldcapacity|监视老年代已使用的最大最小空间
-gcpermcapacity|监视永久代已使用的最大最小空间
-compiler|输出JIT编译器编译过的方法，耗时等信息
-printcompilation|输出已被JIT编译过的方法

>JIT编译器：可将java字节码文件转换为可控处理器执行的指令

*	jinfo：java配置信息工具

	*	实时查看虚拟机的各项参数

*	jmap:生成堆转储快照（一般称为heapdump或dump文件）

	*	还可以查询finalize执行队列，java堆和永久代的详细信息

*	jhat：虚拟机堆转储快照分析工具

	*	一般不推荐使用，效率较低

*	jstack：java堆栈跟踪工具

	*	用于生产虚拟机当前时刻的线程快照
>线程快照是当前虚拟机内每一条正在执行的线程的java堆栈信息的集合
>生成快照的目的是获取线程执行时间过长的原因
>>主要有等待外部资源，死循环，锁等待等

*	HSDIS：JIT生成代码反汇编

<h2 id='3.2'>JDK的可视化工具</h2>

*	JConsole：一种基于JMX的可视化监视，管理工具
*	VisualVM

>基于netbeans平台开发，不需要被监视的程序基于特殊Agent运行，因此对于应用程序的实际性能的影响很小

***

<h1 id='4'>调优案例分析与实战</h1>

<h2 id='4.1'>实例</h2>

<h3 id='4.1.1'>高性能硬件上的程序部署策略</h3>

目前主要有两种方式：

<h4 id='4.1.1.1'>1.通过64位JDK来使用大内存</h4>

可能存在的问题：

*	内存回收导致的长时间停顿
*	64位JDK的性能测试低于32位
*	当产生堆溢出时无法生成转储文件，即便生成转储文件也无法分析
*	可能占用大量内存空间，由于数据类型对齐补白等因素造成

<h4 id='4.1.1.2'>2.使用若干个32位虚拟机建立逻辑集群来利用硬件资源</h4>

可能存在的问题：

*	磁盘竞争容易导致IO异常
*	本地缓存容易占用内存空间
*	无法避免32位JDK的内存限制
*	无法高效利用某些资源池，例如连接池等

<h3 id='4.1.2'>集群间同步导致内存溢出</h3>

<h3 id='4.1.3'>堆外内存导致的溢出错误</h3>

Direct Memory是在划分给堆内存之外的内存中分配的。它不会在MinorGC中进行GC，只能等待FullGC时“顺便”回收其中的内容。NIO会用到大量的DirectMemory内容。可能会造成DirectMemory中的内存溢出

<h3 id='4.1.4'>外部命令导致系统缓慢</h3>

Java的Runtime.getRuntime().exec()方法可以调用外部shell脚本，但是这种调用方式是通过创建一个与当前虚拟机环境相同的进程实现的。这种方法非常消耗内存与系统资源。可以改为使用java API的方式获取

<h3 id='4.1.5'>不恰当数据结构导致内存占用过大</h3>

这种情况虚拟机层面的修改是不行的，需要更改数据结构

<h3 id='4.1.6'>由windows虚拟内存导致的长时间停顿</h3>

在GUI程序中，可能存在最小化时程序被提交到磁盘进行保存的情况。这样的话，退出最小化就需要读磁盘内容，导致不正常GC停顿。
要避免这种情况，可以加入参数 `Dsun.awt.keepWorkingSetOnMinimize=true`

***

<h1 id='5'>类文件结构</h1>

<h2 id='5.2'>无关性的基石</h2>

>java虚拟机支持许多其他语言运行在其上，但是java虚拟机不和语言绑定，只与.class文件相关联

<h2 id='5.3'>Class类文件结构</h2>

>Class文件是一组以8位字节为基础单位的二进制流,各个数据项目严格按照顺序紧凑的排列在Class文件之中，中间没有添加任何的分割符，使得整个Class文件中存储的几乎都是必要的数据。不存在空隙

<h3 id='5.3.1'>魔数与Class文件版本</h3>


![1558324366.png](.\test\1558324366.png)



>每个Class文件的头4个字节称为魔数，用于标识一个Class文件是否能被Java虚拟机所识别
>>之所以不使用文件后缀名，是因为后缀名可能被任意修改，不够安全
>>>如 gif 和 jpg 等的文件都存在魔数

>java的 class 文件的魔数是`CAFEBABE`

紧接着魔数的第五六字节是次版本号，第七八字节是主版本号

<h3 id='5.3.2'>常量池</h3>

紧接着主次版本号的是常量池入口
>常量池可以理解为Class文件之中的资源仓库
>>常量池中的容器计数从1开始

常量池包括:

*	字面量（类似java的常量）

*	符号引用包括：

	*	类和引用的全限定名
	*	字段的名称和描述符
	*	方法的名称和描述符

<h3 id='5.3.3'>访问标志</h3>

>常量池结束之后，紧接着的两个字节代表访问标志，用于识别一些类或者接口的访问信息

<h3 id='5.3.4'>类索引、父类索引和接口索引集合</h3>

类索引`this_class`,父索引`super_class`都是一个u2类型的数据
接口索引`interfaces`是一个u2类型数据的集合

>Class文件中定义了u1，u2和u4类型的数据分别代表1,2,4字节的无符号数

上图中，从偏移地址0x000000F1开始的三个u2类型的值分别为`0x0003`,`0x0004`,`0x0000`,表示类索引为3，，父类索引为4，接口索引集合大小为0。对应常量池即可找出类和父类的常量

![1558340444.png](.\test\1558340444.png)

<h3 id='5.3.5'>字段表集合</h3>

>字段表用于描述接口或者类中声明的变量
>>字段表述类级变量以及实例变量，不包括方法内的局部变量

字段表结构：

类型|名称|数量
:--:|
u2|access_flags|1
u2|name_index|1
u2|descriptor_index|1
u2|attributes_count|1
u2|attribute|attributes_count

<h3 id='5.3.6'>方法表集合</h3>

类似字段表集合

**因为关键字volatile和transient不能修饰方法，所以少了两个关键字。但是多了synchronized，strictfp，native和abstract关键字**

方法表集合的入口地址是：`0x00000101`

<h3 id='5.3.7'>属性表集合</h3>

>在class文件，字段表，方法表都可以携带自己的属性表集合，用于描述某些场合的专有信息

属性表结构：

类型|名称|数量
--|:--:|:--:
u2|attribute_name_index|1
u4|attribute_length|1
u1|info|attribute_length

*	code属性

	*	code是class文件中最重要的一个属性，若将一个java程序中的信息分为代码（code）和元数据（Metadata，包括类，字段方法定义和其他信息），code属性用于描述代码，其他所有信息用于描述元数据

*	Exceptions属性

*	LineNumberTable属性（非必须）

	*	用于描述java源码行号与字节码行号之间的对应关系

*	LocalVariableTable属性（非必须）

	*	用于描述栈帧中局部变量表中的变量与java源码中的变量的关系
    
*	SourceFile属性（非必须）

	*	用于记录生成这个class文件的源码文件的名称

*	ConstantValue

	*	通知虚拟机自动为静态变量赋值

*	InnerClass属性

	*	用于记录内部类与宿主类之间的关系

*	Deprecated与Synthetic属性

	*	布尔属性，无概念，只有存在与否

*	StackMapTable属性

	*	类型检查验证器
	>在java开发场景中需要对许多属性值进行类型验证。如web开发中，表单提交的数据后台处理中需要对传入的值进行验证

*	Signature属性（非必须）

	*	记录泛型签名信息
	>java泛型采用的是擦除方式，即字节码编译之后，泛型信息就被擦除掉。这与C#等强反省语言就有区别。所以java通过Signature属性实现泛型的获取，弥补了这一缺点

*	BootStrapMethods属性

	*	用于保存invokedynamic指令引用的引导方法限定符

<h2 id=5.4>字节码指令</h2>

若不考虑异常处理的话，java虚拟机的解释器可以使用如下伪代码作为基本模型

~~~java
do{
	pc寄存器的值+1
    根据pc寄存器指示的位置，从字节码流中获取操作码
    if(操作码存在操作数)
    	获取操作数
    执行对应操作
}while(字节码流长度>0)
~~~

<h3 id='5.4.1'>字节码与数据类型</h3>

在java虚拟机指令集中，操作数包含其对应的操作的数据类型信息

然而，大多说指令没有对于byte，short，char，boolean的操作。这些数据类型的操作是通过转化为int类型来实现的

**下面将字节码指令集按照用途分为了9类**

*	加载和存储指令

	*	主要是将一个变量从局部变量表加载到操作数栈以及相反的过程
		*	load：将局部变量加载到操作数栈
		*	push：将常量加载到操作数栈
			>常量是有名字的，保存在内存中。若是在代码中修改了初始化的值，则整个引用到该常量的值都会发生变化
			>常数就是数字
		*	store：将操作数栈中的操作数存储在局部变量表中
	
	>指令后面若是带有数字，则表示为其所带有的操作数数量

*	运算指令

	*	**浮点数运算时，最接近数舍入模式**
	*	**浮点数转换为整数时，向零舍入模式**
	*	**long类型比较时，采用带符号比较方式**
	*	**浮点数比较时，采用IEEE754规定的无信号比较方式**

*	类型转换指令

	*	宽化类型转换
	*	窄化类型转换
	>尽管窄化过程中可能出现数据精度丢失，溢出等问题，但是java虚拟机不会抛出运行时异常

*	对象创建与访问指令

	*	虽然类实例和数组都是对象，但是java虚拟机对类实例和数组的创建和操作使用了不同的字节码指令
	
	>checkcast和instanceof：checkcast和instanceof实际上很像，只是前者失败时会返回一个异常，instanceof会返回一个值


*	操作数栈管理指令

	*	类似操作普通的堆栈，新增一个将栈顶端的两个元素互换：`swap`
    
*	控制转移指令

	*	让java虚拟机有条件或者无条件从指定位置而不是控制转移指令的下一条指令开始执行
	条件分支等
    
*	方法调用和返回指令

	*	方法调用指令和数据类型无关，而方法返回指令与返回的数据类型是相关的

*	异常处理指令

	*	显式抛出异常：athrow
	*	处理异常：异常表

*	同步指令（使用管程支持）

	*	方法级同步（隐式）
	*	方法内部一段指令序列同步（通过synchronized关键字实现）

<h2 id='5.5'>共有设计和私有实现</h2>

<h2 id='5.6'>Class文件结构的发展</h2>

**class文件格式具备平台中立、紧凑、稳定和可扩展的特点**

***

<h1 id='6'> 虚拟机类加载机制</h1>

<h2 id='6.1'>类加载的时机</h2>

类从被加载到虚拟机内存开始，到被卸载，共经历了七个阶段

![类的生命周期.png](.\类的生命周期.png)

**其中，加载，验证，准备，初始化，卸载的 *开始时间* 需要按顺序依次完成**

java规范没有规定什么时候执行加载操作，由虚拟机自行决定。
但是，以下情况需要执行初始化操作（当然，之前的操作因为就必须完成）

*	使用java.lang.reflecion的反射方法生成类的时候

*	加载一个类时，如果其父类还未被初始化，需要先初始化其父类

*	虚拟机启动时，需要有一个主类用于执行，这个主类需要首先被初始化
*	遇到new，getstatic，putstatic和invokestatic时，如果类还未被初始化，则需要对其初始化

**通过主类引用父类的static字段，只会执行父类的static字段，而不会执行子类的**

**java访问数组会执行边界检查，这样更加安全，但是牺牲了速度**

[java与c++的优劣](https://blog.csdn.net/self_knowledge/article/details/76590058)

>接口与类在初始化上的区别在于：
>*	类在初始化的时候要求其父类全部都已经初始化过了
>*	接口初始化时不做要求，只有在使用到对应的父接口时进行初始化


<h2 id='6.2'>类加载的过程</h2>

加载，验证，准备，解析，初始化

<h3 id='6.2.1'>1、加载</h3>

虚拟机在加载阶段需要完成的工作：

*	通过类的全限定名获取其字节流

*	将其字节流所表示的静态存储结构转化为运行时存储结构
*	内存中生成一个类的Class对象，作为方法区这个类的各种数据的访问入口

加载和连接的部分操作是交替进行的，可能加载阶段尚未完成，连接阶段已经开始了。但是开始时间保持的先后顺序

<h3 id='6.2.2'>2、验证</h3>

验证阶段包括如下四个操作：

1.	文件格式验证
	*	对比class文件格式。为了保证输入的字节流能够正确的存储在方法区之中

	**ps：接下来的操作全部是在方法区之中的**

2.	元数据验证
	*	对字节码元数据语义进行分析，保证其不存在不符合java语言规范的部分

3.	字节码验证
	*	对方法体进行校验分析，保证校验类的方法在运行时不会做出危害虚拟机安全的事件

4.	符号引用验证
	*	解析阶段中发生，目的是确保类解析阶段的正常执行

验证阶段很重要，但不是必须，可以通过Xverify：none来关闭验证

<h3 id='6.2.3'>3、准备</h3>

正式为类变量赋值并设置类变量初始值，这些变量所使用的内存都将在方法区中进行分配

<h3 id='6.2.4'>4、解析</h3>

虚拟机将常量池内的符号引用替换为直接引用的过程

>	符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可
>>	对象字面量就是引号引起来的部分，必须是等号右边的部分
>>	~~~java
>>	int b=20;//b是变量，20就是字面量
>>	~~~
>
>	直接引用：可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄

*	类或接口的解析

*	字段解析

*	类方法解析

*	接口方法解析

	*	**由于接口中的方法默认都是public的，所以不存在访问权限问题，因此接口方法的符号应该不会抛出java.lang.IllegalAccessError异常**


<h3 id='6.2.5'>5、初始化</h3>

类加载过程的最后一步，初始化阶段才是真正执行java代码

	<clinit>()方法是执行初始化的方法
    
	其对于类或者接口不是必须的，若是没有static方法或者变量的赋值操作，就可以没有<clinit>（）方法
    接口与类一样都能生成clinit方法
    如果是多线程的话，只有一个线程执行初始化操作，其他线程阻塞，被阻塞的线程在退出阻塞状态后，不会执行初始化（同一个类加载器下，一个类型只会被初始化一次）

<h2 id="6.3">类加载器</h2>

<h3 id="6.3.1">类与类加载器</h3>

类加载阶段的"通过一个类的全限定名去获取字节流"在java虚拟机中完成，以便应用程序自行决定需要获取的类。实现这一操作的模块称为"类加载器"

**不同的类加载器加载的类是不同的，即便两个类来源于同一个class文件，使用同样的虚拟机加载**

<h3 id="6.3.2">双亲委派模型</h3>

从java虚拟机角度看，类加载器分为两类：

*	启动类加载器

	*	java虚拟机本身就有的类加载器

*	其他所有类加载器

	*	都是继承自`java.lang.ClassLoader`

从开发人员角度看，类加载器分为三类：

*	启动类加载器

*	扩展类加载器

*	应用程序类加载器

**类的双亲委派模型**

类加载器的层次关系称为双亲委派模型

**非强制，java虚拟机推荐的类加载方式**

![1559012973.png](.\1559012973.png)

*	除了顶层的启动类加载器之外，其余类加载器都有自己的父类加载器
*	这里的父子类加载器不是以继承关系实现的，而是以组合关系复用父类加载器的代码

类加载流程：

*	一个类加载器收到加载类的请求
*	将请求委派给父类加载器去完成（调用父类的loadClass（）方法）
*	一直向上传递，直到顶层启动类加载器
*	只有当父类加载器无法完成加载时，子类加载器才考虑自己加载（调用自己的findClass（）方法）

优点：

*	不会造成类加载器名字的混乱
*	具有明确的层级系统

<h3 id="6.3.3">破坏双亲委派模型</h3>

三次
这里的“破坏”并非不好的意思

1.	双亲委派之前：通过重写父类的loadClass（）方法实现子类的findClass（）功能
2.	模型自身的缺陷：父类想要调用其他代码时，例如JNDI（java命名和目录接口）引入了线程上下文类加载器
3.	为了满足程序的动态性，实现代码热替换等：OSGI（java语言服务规范）模型，引入了平级委派的思想

***

<h1 id="7">虚拟机字节码执行引擎</h1>

所有的java虚拟机执行引擎都是一样的：输入字节码文件，处理过程是字节码解析等效过程，最后生成结果

<h2 id="7.1">运行时栈帧结构</h2>

虚拟机栈的栈元素
包含：

*	局部变量表
*	操作数栈
*	动态链接
*	方法返回地址
*	附加信息

**一个方法执行过程中，只有位于虚拟机栈栈顶的栈帧（当前栈帧）有效，与当前栈帧关联的方法是当前方法**

<h3 id="7.1.1">局部变量表</h3>

以容量槽`slot`为基本单位
大小为32个位`boolean`，`byte`，`char`，`short`，`float`，`reference`，`int`，`returnAddress`
对于64位数据类型，需要分配两个连续的`slot`(以高位对齐的方式)

类变量的两次初始化：

*	准备阶段，系统赋初值
*	初始化阶段，程序员自定义初值

局部变量只有一次初始化：

*	程序员自定义

<h3 id="7.1.2">操作数栈</h3>

后入先出

32位数据类型所占的栈容量为1
64位数据类型所占的栈容量为2

>大多数虚拟机会对栈帧进行一定程度的优化，即两个栈帧可能存在重叠区域，操作数栈和局部变量表的共享区域可能存在重合

<h3 id="7.1.3">动态连接</h3>

*	静态解析
	*	一部分符号引用在类加载阶段就转化为直接引用

*	动态连接
	*	另一部分运行时转化为直接引用

<h3 id="7.1.4">方法返回地址</h3>

*	正常退出（有无返回值）
*	异常退出

>方法退出实际上就相当于栈帧的出栈过程。栈帧可能还需要保存方法退出的一部分信息，用于返回上层的调用方法等

<h3 id="7.1.5">附加信息</h3>

<h2 id="7.2">方法调用</h2>

不同于方法执行，方法调用唯一的任务就是确定被调用方法的版本

<h3 id="7.2.1">解析</h3>

>调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法调用称为解析

java虚拟机中提供的方法调用字节码指令

*	invokestatic：调用静态方法
*	invokespecial：调用实例构造器`<init>`方法,私有方法和父类方法
*	invokevirtual：调用所有的虚方法
*	invokeinterface：调用接口方法
*	invokedynamic：先在运行时动态解析出调用电限定符所引用的方法，然后在执行该方法

<h3 id="7.2.2">分派</h3>

>解析调用是一个静态的过程，在编译期就完全确定；而分派调用可能是静态也可能是动态。分派是多态性的体现

*	静态分派

    *	静态类型和实际类型
    ~~~java
    Human man=new Man()
    man=new Woman()
    //实际类型变化
    ~~~
    ~~~java
    sr.sayHello((Man)man)
    sr.sayHello((Woman)man)
    //静态类型变化
    ~~~

	>静态类型的变化仅仅在使用阶段发生，变量本身的静态类型不会变化
	>编译阶段，javac编译器会根据参数的静态类型决定重载哪个版本

	*	重载的优先级

	本类型->自动类型转换
    char->int->long->Character->Serializable->Object->char...（可变长度参数列表）

*	动态分派

**静态分派对应重载，动态分派对应重写**

*	重写的本质

	>由于invokevirtual指令执行的第一步就是在运行期确定接受者的实际类型，所以两次调用过程中的invokevirtual指令将常量池中的类方法符号引用解析到了不同的直接引用上

*	单分派与多分派

	>java语言是一门静态多分派，动态单分派的语言

<h3 id="7.2.3">动态类型语言支持</h3>

**JDK7中invokedynamic指令的出现，使得JDK实现了对于动态类型语言的支持**

*	动态类型语言
	>类型检查主体在运行期而不是编译期，在运行期确定类型

**java语言无法将函数作为一个参数传递**

*	MethodHandle机制
	>为了解决除了invokedynamic之类之外的另外四条invoke指令被固化在java虚拟机中的问题，使得查找目标方法被释放到代码层面，增加程序员的自由度

	reflection和MethodHandle的区别

Reflection|MethodHandl
:--:|:--:
模拟java代码层次的方法调用|模拟字节码层次的方法调用
java.lang.reflect.Method中包含的信息更多，重量级|java.lang.invoke.MethodHandle包含的信息较少，轻量级
不支持|可以进行虚拟机层面的各种优化

*	iovokedynamic指令
	
    **目的和MethodDynamic机制相同，一个是在代码层面的变化，一个是在虚拟机指令层面的变化**
    
    [invokedynamic指令详解](https://www.infoq.cn/article/Invokedynamic-Javas-secret-weapon)