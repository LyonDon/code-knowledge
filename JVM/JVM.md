

![性能调优.jpg](.\性能调优.jpg)

![jvm和性能优化.jpg](.\jvm和性能优化.jpg)

[一、java内存区域与内存溢出异常](#1)

[1.1 JVM内存结构 vs Java内存模型 vs Java对象模型](#1.1)
[1.1.1 JVM内存结构](#1.1.1)
[1.1.2 JVM内存模型](#1.1.2)
[1.1.1 JVM对象模型](#1.1.3)

[1.2 类加载系统(Class Loader SubSystem)](#1.2)
[1.2.1 加载](#1.2.1)
[1.2.1 链接](#1.2.2)
[1.2.1 初始化](#1.2.3)

[1.3 运行时数据区](#1.3)
[1.3.1 方法区（JVM共享）](#1.3.1)
[1.3.2 堆区（JVM共享）](#1.3.2)
[1.3.3 栈区（java虚拟机栈）](#1.3.3)
[1.3.4 PC寄存器区](#1.3.4)
[1.3.5 本地方法栈区](#1.3.5)

[1.4 执行引擎](#1.4)
[1.4.1字节码文件](#1.4.1)

[1.5 OutOfMemory异常](#1.5)
[1.5.1 Java堆溢出](#1.5.1)
[1.5.2 虚拟机栈和本地方法栈溢出](#1.5.2)
[1.5.3 方法区和运行时常量池溢出](#1.5.3)
[1.5.4 本机直接内存溢出](#1.5.4)

[二、GC与内存分配策略](#2)


[2.1 GC基本方式](#2.1)
[2.1.1 标记清除](#2.1.1)
[2.1.2 复制收集](#2.1.2)
[2.1.3 引用计数](#2.1.3)
[2.1.4 分代收集算法（广泛使用）](#2.1.4)
[2.1.5 可达性分析算法](#2.1.5)
[2.1.6 引用](#2.1.6)

[2.2 垃圾收集器](#2.2)
[2.2.1 GMS](#2.2.1)
[2.2.2 G1收集器](#2.2.2)

[2.3 回收方法区](#2.3)

[2.4 对象](#2.4)
[2.4.1 对象的创建](#2.4.1)
[2.4.2 对象的内存布局](#2.4.2)
[2.4.3 对象的访问定位](#2.4.3)

[2.5 HotSpot算法实现](#2.5.1)

[2.6 其他](#2.6)
[2.6.1 MinorGC和MajorGC](#2.6.1)
[2.6.2 长期存活的对象进入老年代](#2.6.2)
[2.6.3 动态对象年龄判断](#2.6.3)

[三、虚拟机性能与故障处理工具](#3)

[3.1 JDK命令行工具](#3.1)
[3.2 JDK可视化工具](#3.2)

<h1 id='1'>Java内存区域与内存溢出异常</h1>

<h2 id='1.1'>JVM内存结构 vs Java内存模型 vs Java对象模型</h2>

<h3 id='1.1.1'> JVM内存结构</h3>

与JVM运行时内存有关，虚拟机会在java程序执行过程中将其所管理的内存分为不同的区域，分别负责不同的功能

*	上层：PC寄存器、java虚拟机栈、本地方法栈
*	中层：Java堆、运行时常量池
*	下层：线程内存区域、运行时常量

![1554085192.png](.\1554085192.png)

<h3 id='1.1.2'> JVM内存模型</h3>

JMM，主要围绕多线程中出现的原子性，可见性，顺序性等问题及多线程通信的相关特性而建立的模型。Java线程间通信是通过共享内存实现的

*	原子性对应的是处理器优化
*	顺序性对应的是指令重排序
*	可见性对应的是缓存一致性问题

![1554085095.png](.\1554085095.png)

<h3 id='1.1.3'> JVM对象模型</h3>

主要表示的是java对象在JVM中的存储结构

***


<h2 id='1.2'>类加载系统(Class Loader SubSystem)</h2>

<h3 id='1.2.1'>加载</h3>

1.	Boot Strap class Loader：加载系统引导类
2.	Extension class Loader：加载拓展类
3.	Application class Loader：加载应用层级类

<h3 id='1.2.2'>链接</h3>

1.	Verify：验证字节码是否正确
2.	Prepare：分配静态变量并设置默认值
3.	Resolve：符号引用被替换为指向方法区的原始引用

<h3 id='1.2.3'>初始化</h3>

**类加载的最后一步，所有静态变量都会被赋值，从父类到子类执行**


<h2 id='1.3'>运行时数据区</h2>

<h3 id='1.3.1'>方法区（ JVM 共享）</h3>

*保存类，成员信息，父类和接口信息，运行时常量池*

与 java 堆一样，是各个线程共享的内存区域，主要用于对于常量池的内存回收和对类的卸载，如果方法区溢出，则会抛出 outOfMemoryError

>由 java 虚拟机自带的类加载器所加载的类，始终不会被卸载。用户自定义的类加载器所加载的类可能会被卸载。类的卸载是指被 GC 回收

<h3 id='1.3.2'>堆区（ JVM 共享）</h3>

*保存所有对象信息*

在虚拟机启动时创建，为所有线程所共享，所有的对象实例和数组都要在堆上分配

<h3 id='1.3.3'>栈区（ java 虚拟机栈）</h3>

*每个线程的栈*

与PC寄存器一样，虚拟机栈是线程私有的，每一个方法从调用到执行完成的过程，就对应着栈帧在虚拟机中的入栈和出栈过程，为虚拟机执行 java 方法服务

<h3 id='1.3.4'>PC 寄存器区</h3>

*保存当前指令地址，若执行的是本地方法，则 PC 为 null*

一块较小的内存区域，可以看做是当前线程执行字节码的行号指示器

<h3 id='1.3.5'>本地方法栈区</h3>

*与栈区相似，只是保存的是本地方法*

具体的虚拟机可以自由实现本地方法栈区

<h2 id='1.4'>执行引擎</h2>

*	字节码解释器	可以执行字节码

*	模板解释器	直接将对应的指令集转换为本地代码

*	JIT编译器	优化代码

*	垃圾收集器	回收不用的内存和对象

*	Java Native Interface	简称JNI，暴露本地方法接口，使得java程序可以执行本地方法

*	Native Method Libraries	本地方法库

<h3 id='1.4.1'>字节码文件</h3>

字节码文件就是java源文件经过编译之后形成的.class文件，用于JVM进行处理。每一个字节码文件对应一个class或者interface的定义信息，即便一个java文件中定义了多个class或者interface，其对应的.class文件表示的是它们的全部

***

<h2 id='1.5'>OutOfMemory异常</h2>

<h3 id='1.5.1'>Java堆溢出</h3>

java堆内存中的OOM异常实际上就是常见的内存溢出异常

*	处理java堆内存问题:

	1.	通过内存映像分析工具对dump出来的堆转储快照进行分析,确认内存中的对象是否是必要的

	2.	区分是内存泄漏还是内存溢出
		-	内存泄漏
			查看GCRoots的引用链

    	-	否则,检查虚拟机的堆参数

<h3 id='1.5.2'>虚拟机栈和本地方法栈溢出</h3>

*	java虚拟机描述了两种异常

	-	当线程申请的栈深度大于虚拟机所允许的最大栈深度,报StackOverflowError

	-	当虚拟机在扩展栈时无法申请到足够的空间时,报OutOfMemoryError

**然而,实验表明,在单个线程下,无论是栈帧太大还是虚拟机栈容量太小,当内存无法分配时,都会报出StackOverflowError**

>栈帧就是存储在用户栈或者内核栈上的每次函数调用的记录单元

*	可以通过建立多线程导致内存溢出.然而,在无法更换内存地址的情况下,只能通过减少最大栈和减少栈容量来换取更多的线程

<h3 id='1.5.3'>方法区和运行时常量池溢出</h3>

*	比较常见,一个类要被垃圾回收器回收掉,判定条件是比较苛刻的.在大量动态生成class类文件的应用中,需要特别注意类的回收情况

<h3 id='1.5.4'>本机直接内存溢出</h3>

*	虽然可以使用DirectMemory指定分配内存（不指定的话默认是java堆的最大内存），但是DirectMemory实际上没有分配内存，而是通过计算得知无法获得足够内存。这时就可以使用Unsafe类

>Java本来被设计为一种安全的受控环境,但是,还是存在一个后门.提供了一些可以直接操作线程和内存的低层次环境,这个后门类叫做unsafe。极不建议使用，因为对于内存的直接操作可能会造成不可预知的后果

***

<h1 id='2'>GC与内存分配策略</h1>

<h2 id='2.1'>GC基本方式</h2>

<h3 id='2.1.1'>标记清除</h3>

	*	为引用的对象设置标记。通过两次查找实现，第一次从根部开始，类似树的遍历过程一样，对每个引用的对象设置标记。第二次继续从根部开始，查找全部对象，对于没有标记的对象直接释放其所持有的内存
	
    	+	优点：好理解
        +	缺点：如果被引用的对象占所有对象的比例比较小，则需要遍历全部对象，系统消耗较大

<h3 id='2.1.2'>复制收集</h3>

	*	试图解决标记清除带来的问题。另外开辟一块空间，遍历一次，将被引用的对象根据其引用关系存储在新开辟的空间中。然后直接将原空间当做垃圾回收
	
    	+	优点：一定程度上减少了系统开销，对于引用对象比例较低的情况比较适用；同时还有局部性的好处，即相互引用的对象其存储位置也会比较接近，这样提高了访问速度
        +	缺点：对于引用对象比例较高的情况，开辟新的内存空间会比较消耗内存，提高开销

<h3 id='2.1.3'>引用计数</h3>

	*	对于所有对象，按照其被引用的次数进行计数。当引用失效时，就实时减少其对应的引用数；反之亦然。

		+	优点：实现更加容易；更动态，细粒度；由于释放机制是针对个别来实现的，所以中断由GC产生的中断时间更短
        +	缺点：无法应对循环引用；依赖于计数，如果计数出现错误，则很难发现；多线程情况下可能会出现一致性问题（由于这一点的存在，java的实现上没有采用这种方法）

<h3 id='2.1.4'>分代收集算法（现在的多说虚拟机采用方式）</h3>

	*	根据对象存活周期将java堆分为新生代和老年代

		*	新生代中的对象存活时间短，采用复制收集算法
		*	老年代中的对象存活时间长，采用标记清除算法

<h3 id='2.1.5'>可达性分析算法</h3>

	*	java中使用的是这种方式，类似于标记清除算法（只是通过的是引用链）

	*	可作为GCRoots对象的包括以下几种：

        *	虚拟机栈中引用的对象
        *	方法区中静态属性引用的对象
        *	方法区中常量引用的对象
        *	本地方法栈中JNI（即一般说的Native方法）引用的对象

<h3 id='2.1.6'>引用</h3>

上面这几种方式，都使用了引用的概念。java种的引用分为以下几种：

*	强引用
	*	就是类似`Object obj=new Object()`这样的引用，只要引用存在，GC就不能回收

*	软引用
	*	描述一些有用但非必须的对象

*	弱引用
	*	描述非必须对象，其存活时间只维持到下一次的GC之前

*	虚引用
	*	最弱的引用关系，只是为了在对象被回收的时候能够返回一个通知


<h2 id='2.2'>垃圾收集器</h2>

**三种垃圾收集器**

*	串行收集器：单线程，适用数据量较小的情况
*	并行收集器：对吞吐量有要求的大中型应用，响应时间可能比较ch
*	并发收集器：对响应速度有要求的大中型应用

*	新生代
	*	Serial，parallel Scavenge（吞吐量），ParNew

*	老年代
	*	Serial Old，Parallel Old，CMS

*	新生代+老年代
	*	G1

<h3 id='2.2.1'>CMS</h3>

**步骤：**

1.	初始标记
2.	并发标记
3.	重新标记
4.	清除并发

**是一种 标记-清除 垃圾收集器**

*	由于其可以与用户线程并发执行，所以是一种并发，低停顿的垃圾收集器

*	比较适用于对响应速度要求较高的情况

**存在三个比较明显的缺点：**

*	对CPU资源非常敏感

*	无法处理浮动垃圾

*	“标记-清除”算法容易产生大量的空间碎片

<h3 id='2.2.2'>G1收集器</h3>

步骤：

1.	初始标记
2.	并发标记
3.	最终标记
4.	筛选回收

**最前沿的垃圾收集器**

*	并行与并发
*	分代收集
*	空间整合

>区别于CMS的“标记-清除”算法，G1是“标记-整理”算法，不会产生大量的空间碎片

*	可预测的停顿

***

**Java的内存管理总结起来就两个方面**

*	给对象的内存分配
*	回收分配给对象的内存

<h2 id='2.3'>回收方法区</h2>

**方法区的垃圾回收相比于堆区而言，效率很低。这也是很多人认为方法区不存在垃圾回收的原因**

*	永久代的垃圾回收

	*	废弃常量
	*	无用的类

>永久代是HotSpot虚拟机特有的概念，是方法区的一种实现。在java8中被取消，取而代之的是元空间

<h2 id='2.4'>对象</h2>

<h3 id='2.4.1'>对象的创建</h3>

~~~mermaid
graph TD

类加载检查-->为新生对象分配内存
为新生对象分配内存-->指针碰撞
为新生对象分配内存-->空闲列表

类加载检查-->安全性考虑
安全性考虑-->CAS失败重试
安全性考虑-->内存分配按照线程划分到不同空间

为新生对象分配内存-->内存空间初始化为0
内存空间初始化为0-->对对象进行必要设置
~~~


<h3 id='2.4.2'>对象的内存布局</h3>

-	对象头
-	实例数据
-	对齐填充

<h3 id='2.4.3'>对象的访问定位</h3>

由于对象在虚拟机栈中只保存了一个指针的引用，所以对于对象的访问方式取决于虚拟机的具体实现，两种方式：

*	句柄：更稳定，不需要修改reference
*	直接指针，速度更快，省去了到对象实例数据的指针，省去了一次指针定位的时间


<h2 id='2.5'>HotSpot算法实现</h2>

*GC执行时必须停止所有java执行线程，因为对象间的引用关系不能在GC的时候发生更改*

**安全点的设置**

基于上一点，需要设置安全点，使得系统在安全点上才进行GC

安全点的设置时间不能太长也不能太短。基本上以下面的标准进行选定：
>是否具有让程序长时间执行的特征

安全点是通过轮询CPU中断来实现的，与轮询中断标志为真的时间相重合

***



<h2 id='2.6'>其他</h2>

<h3 id='2.6.1'>MinorGC和MajorGC</h3>

*	MinorGC（新生代GC）：指的是在新生代发生的垃圾收集算法，比较频繁，速度较快

*	MajorGC（老年代GC）：指的是在老年代发生的垃圾收集算法，比MinorGC的速度慢十倍以上

<h3 id='2.6.2'>长期存活的对象将进入老年代</h3>

>若对象在Eden区出生，经过一次MinorGC依然存活，且能够被Survivor区容纳则将其放入Survivor区,并将其**年龄计数器**置为1。在这之后，每经过一次MinorGC，计数器加一，当年龄计数器的值为MaxTenuringThreshold（一般为15）时，将对象放入老年代

<h3 id='2.6.3'>动态对象年龄判定</h3>

虚拟机并不是强制要求需要大于MaxTenuringThreshold的值才放入老年代，而是当超过半数的对象处于相同年龄，大于这个年龄的对象就能放入老年代

*只要老年代剩余空间大小大于新生代总空间大小或者历次晋升的平均空间大小就会进行MinorGC*

***

<h1 id='3'>虚拟机性能监控与故障处理工具</h1>

<h2 id='3.1'>JDK命令行工具</h2>

*	jps:可以列出

	+	正在执行的虚拟机进程
	+	其唯一的进程ID
	+	主类所在的类名

*	jstat：监视虚拟机的各种运行状态

	*	jstat工具主要选项：

		选项|作用
:--:|:--:
-class|监视器装载，卸载数量等
-gc|监视java堆使用情况，包括Eden区，两个survivor区，老年代，永久代等，以及GC时间
-gccapacity|同上，输出主要关注java堆的使用情况
-gcutil|同上，输出主要关注已使用空间占总空间的百分比
-gccause|同上，输出主要关注引起变化的原因
-gcnew|监视新生代GC情况
-gcnewcapacity|监视新生代已使用的最大最小空间
-gcold|监视老年代GC情况
-gcoldcapacity|监视老年代已使用的最大最小空间
-gcpermcapacity|监视永久代已使用的最大最小空间
-compiler|输出JIT编译器编译过的方法，耗时等信息
-printcompilation|输出已被JIT编译过的方法

>JIT编译器：可将java字节码文件转换为可控处理器执行的指令

*	jinfo：java配置信息工具

	*	实时查看虚拟机的各项参数

*	jmap:生成堆转储快照（一般称为heapdump或dump文件）

	*	还可以查询finalize执行队列，java堆和永久代的详细信息

*	jhat：虚拟机堆转储快照分析工具

	*	一般不推荐使用，效率较低

*	jstack：java堆栈跟踪工具

	*	用于生产虚拟机当前时刻的线程快照
>线程快照是当前虚拟机内每一条正在执行的线程的java堆栈信息的集合
>生成快照的目的是获取线程执行时间过长的原因
>>主要有等待外部资源，死循环，锁等待等

*	HSDIS：JIT生成代码反汇编

<h2 id='3.2'>JDK的可视化工具</h2>

*	JConsole：一种基于JMX的可视化监视，管理工具
*	VisualVM

>基于netbeans平台开发，不需要被监视的程序基于特殊Agent运行，因此对于应用程序的实际性能的影响很小


