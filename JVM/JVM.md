
![性能调优.jpg](.\性能调优.jpg)

![jvm和性能优化.jpg](.\jvm和性能优化.jpg)


## JVM内存结构 vs Java内存模型 vs Java对象模型

### JVM内存结构

与JVM运行时内存有关，虚拟机会在java程序执行过程中将其所管理的内存分为不同的区域，分别负责不同的功能

*	上层：PC寄存器、java虚拟机栈、本地方法栈
*	中层：Java堆、运行时常量池
*	下层：线程内存区域、运行时常量

![1554085192.png](.\1554085192.png)

### Java内存模型

JMM，主要围绕多线程中出现的原子性，可见性，顺序性等问题及多线程通信的相关特性而建立的模型。Java线程间通信是通过共享内存实现的

*	原子性对应的是处理器优化
*	顺序性对应的是指令重排序
*	可见性对应的是缓存一致性问题

![1554085095.png](.\1554085095.png)

### Java对象模型         

主要表示的是java对象在JVM中的存储结构

***

# JVM

[1.类加载系统](#1)
[2.运行时数据区](#2)
[3.执行引擎](#3)


<h2 id='1'>类加载系统(Class Loader SubSystem)</h2>

#### 加载

1.	Boot Strap class Loader：加载系统引导类
2.	Extension class Loader：加载拓展类
3.	Application class Loader：加载应用层级类

#### 链接

1.	Verify：验证字节码是否正确
2.	Prepare：分配静态变量并设置默认值
3.	Resolve：符号引用被替换为指向方法区的原始引用

#### 初始化

**类加载的最后一步，所有静态变量都会被赋值，从父类到子类执行**


<h2 id='2'>运行时数据区</h2>

#### *	方法区（ JVM 共享）	

*保存类，成员信息，父类和接口信息，运行时常量池*

与 java 堆一样，是各个线程共享的内存区域，主要用于对于常量池的内存回收和对类的卸载，如果方法区溢出，则会抛出 outOfMemoryError

>由 java 虚拟机自带的类加载器所加载的类，始终不会被卸载。用户自定义的类加载器所加载的类可能会被卸载。类的卸载是指被 GC 回收

#### *	堆区（ JVM 共享）	

*保存所有对象信息*

在虚拟机启动时创建，为所有线程所共享，所有的对象实例和数组都要在堆上分配

#### *	栈区（ java 虚拟机栈）	

*每个线程的栈*

与PC寄存器一样，虚拟机栈是线程私有的，每一个方法从调用到执行完成的过程，就对应着栈帧在虚拟机中的入栈和出栈过程，为虚拟机执行 java 方法服务

#### *	PC 寄存器区	

*保存当前指令地址，若执行的是本地方法，则 PC 为 null*

一块较小的内存区域，可以看做是当前线程执行字节码的行号指示器

#### *	本地方法栈区	

*与栈区相似，只是保存的是本地方法*

具体的虚拟机可以自由实现本地方法栈区

<h2 id='3'>执行引擎</h2>

*	字节码解释器	可以执行字节码

*	模板解释器	直接将对应的指令集转换为本地代码

*	JIT编译器	优化代码

*	垃圾收集器	回收不用的内存和对象

*	Java Native Interface	简称JNI，暴露本地方法接口，使得java程序可以执行本地方法

*	Native Method Libraries	本地方法库

### 字节码文件

字节码文件就是java源文件经过编译之后形成的.class文件，用于JVM进行处理。每一个字节码文件对应一个class或者interface的定义信息，即便一个java文件中定义了多个class或者interface，其对应的.class文件表示的是它们的全部

***

### GC

**三种基本方式**

*	标记清除

	*	为引用的对象设置标记。通过两次查找实现，第一次从根部开始，类似树的遍历过程一样，对每个引用的对象设置标记。第二次继续从根部开始，查找全部对象，对于没有标记的对象直接释放其所持有的内存
	
    	+	优点：好理解
        +	缺点：如果被引用的对象占所有对象的比例比较小，则需要遍历全部对象，系统消耗较大

*	复制收集

	*	试图解决标记清除带来的问题。另外开辟一块空间，遍历一次，将被引用的对象根据其引用关系存储在新开辟的空间中。然后直接将原空间当做垃圾回收
	
    	+	优点：一定程度上减少了系统开销，对于引用对象比例较低的情况比较适用；同时还有局部性的好处，即相互引用的对象其存储位置也会比较接近，这样提高了访问速度
        +	缺点：对于引用对象比例较高的情况，开辟新的内存空间会比较消耗内存，提高开销

*	引用计数

	*	对于所有对象，按照其被引用的次数进行计数。当引用失效时，就实时减少其对应的引用数；反之亦然。

		+	优点：实现更加容易；更动态，细粒度；由于释放机制是针对个别来实现的，所以中断由GC产生的中断时间更短
        +	缺点：无法应对循环引用；依赖于计数，如果计数出现错误，则很难发现；多线程情况下可能会出现一致性问题（由于这一点的存在，java的实现上没有采用这种方法）

*	分代收集算法（现在的多说虚拟机采用方式）

	*	根据对象存活周期将java堆分为新生代和老年代

		*	新生代中的对象存活时间短，采用复制收集算法
		*	老年代中的对象存活时间长，采用标记清除算法
*	可达性分析算法

	*	java中使用的是这种方式，类似于标记清除算法（只是通过的是引用链）

	*	可作为GCRoots对象的包括以下几种：

        *	虚拟机栈中引用的对象
        *	方法区中静态属性引用的对象
        *	方法区中常量引用的对象
        *	本地方法栈中JNI（即一般说的Native方法）引用的对象

#### 引用

上面这几种方式，都使用了引用的概念。java种的引用分为以下几种：

*	强引用
	*	就是类似`Object obj=new Object()`这样的引用，只要引用存在，GC就不能回收

*	软引用
	*	描述一些有用但非必须的对象

*	弱引用
	*	描述非必须对象，其存活时间只维持到下一次的GC之前

*	虚引用
	*	最弱的引用关系，只是为了在对象被回收的时候能够返回一个通知

#### 回收方法区

**方法区的垃圾回收相比于堆区而言，效率很低。这也是很多人认为方法区不存在垃圾回收的原因**

*	永久代的垃圾回收

	*	废弃常量
	*	无用的类

>永久代是HotSpot虚拟机特有的概念，是方法区的一种实现。在java8中被取消，取而代之的是元空间

**三种垃圾收集器**

*	串行收集器：单线程，适用数据量较小的情况
*	并行收集器：对吞吐量有要求的大中型应用，响应时间可能比较ch
*	并发收集器：对响应速度有要求的大中型应用

## 对象
### 对象的创建

~~~mermaid
graph TD

类加载检查-->为新生对象分配内存
为新生对象分配内存-->指针碰撞
为新生对象分配内存-->空闲列表

类加载检查-->安全性考虑
安全性考虑-->CAS失败重试
安全性考虑-->内存分配按照线程划分到不同空间

为新生对象分配内存-->内存空间初始化为0
内存空间初始化为0-->对对象进行必要设置
~~~


### 对象的内存布局

-	对象头
-	实例数据
-	对齐填充

### 对象的访问定位

由于对象在虚拟机栈中只保存了一个指针的引用，所以对于对象的访问方式取决于虚拟机的具体实现，两种方式：

*	句柄：更稳定，不需要修改reference
*	直接指针，速度更快，省去了到对象实例数据的指针，省去了一次指针定位的时间

## OutOfMemory异常

### Java堆溢出

java堆内存中的OOM异常实际上就是常见的内存溢出异常

*	处理java堆内存问题:

	1.	通过内存映像分析工具对dump出来的堆转储快照进行分析,确认内存中的对象是否是必要的

	2.	区分是内存泄漏还是内存溢出
		-	内存泄漏
			查看GCRoots的引用链

    	-	否则,检查虚拟机的堆参数

### 虚拟机栈和本地方法栈溢出

*	java虚拟机描述了两种异常

	-	当线程申请的栈深度大于虚拟机所允许的最大栈深度,报StackOverflowError

	-	当虚拟机在扩展栈时无法申请到足够的空间时,报OutOfMemoryError

**然而,实验表明,在单个线程下,无论是栈帧太大还是虚拟机栈容量太小,当内存无法分配时,都会报出StackOverflowError**

>栈帧就是存储在用户栈或者内核栈上的每次函数调用的记录单元

*	可以通过建立多线程导致内存溢出.然而,在无法更换内存地址的情况下,只能通过减少最大栈和减少栈容量来换取更多的线程

### 方法区和运行时常量池溢出

*	比较常见,一个类要被垃圾回收器回收掉,判定条件是比较苛刻的.在大量动态生成class类文件的应用中,需要特别注意类的回收情况

### 本机直接内存溢出

*	虽然可以使用DirectMemory指定分配内存（不指定的话默认是java堆的最大内存），但是DirectMemory实际上没有分配内存，而是通过计算得知无法获得足够内存。这时就可以使用Unsafe类

>Java本来被设计为一种安全的受控环境,但是,还是存在一个后门.提供了一些可以直接操作线程和内存的低层次环境,这个后门类叫做unsafe。极不建议使用，因为对于内存的直接操作可能会造成不可预知的后果