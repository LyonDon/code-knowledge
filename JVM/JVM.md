## JVM内存结构 vs Java内存模型 vs Java对象模型

#### JVM内存结构

与JVM运行时内存有关，虚拟机会在java程序执行过程中将其所管理的内存分为不同的区域，分别负责不同的功能

*	上层：PC寄存器、java虚拟机栈、本地方法栈
*	中层：Java堆、运行时常量池
*	下层：线程内存区域、运行时常量

![1554085192.png](.\1554085192.png)

#### Java内存模型

JMM，主要围绕多线程中出现的原子性，可见性，顺序性等问题及多线程通信的相关特性而建立的模型。Java线程间通信是通过共享内存实现的

*	原子性对应的是处理器优化
*	顺序性对应的是指令重排序
*	可见性对应的是缓存一致性问题

![1554085095.png](.\1554085095.png)

#### Java对象模型

主要表示的是java对象在JVM中的存储结构

***

## JVM

[1.类加载系统](#1)
[2.运行时数据区](#2)
[3.执行引擎](#3)


<h3 id='1'>类加载系统(Class Loader SubSystem)</h3>

#### 加载

1.	Boot Strap class Loader：加载系统引导类
2.	Extension class Loader：加载拓展类
3.	Application class Loader：加载应用层级类

#### 链接

1.	Verify：验证字节码是否正确
2.	Prepare：分配静态变量并设置默认值
3.	Resolve：符号引用被替换为指向方法区的原始引用

#### 初始化

**类加载的最后一步，所有静态变量都会被赋值，从父类到子类执行**


<h3 id='2'>运行时数据区</h3>

*	方法区（JVM共享）	保存类，成员信息，父类和接口信息，运行时常量池
*	堆区（JVM共享）	保存所有对象信息
*	栈区	每个线程的栈
*	PC寄存器区	保存当前指令地址，若执行的是本地方法，则PC为null
*	本地方法栈区	与栈区相似，只是保存的是本地方法

<h3 id='3'>执行引擎</h3>

*	字节码解释器	可以执行字节码

*	模板解释器	直接将对应的指令集转换为本地代码

*	JIT编译器	优化代码

*	垃圾收集器	回收不用的内存和对象

*	Java Native Interface	简称JNI，暴露本地方法接口，使得java程序可以执行本地方法

*	Native Method Libraries	本地方法库

### 字节码文件

字节码文件就是java源文件经过编译之后形成的.class文件，用于JVM进行处理。每一个字节码文件对应一个class或者interface的定义信息，即便一个java文件中定义了多个class或者interface，其对应的.class文件表示的是它们的全部

***

### GC

**三种基本方式**

*	标记清除

	*	为引用的对象设置标记。通过两次查找实现，第一次从根部开始，类似树的遍历过程一样，对每个引用的对象设置标记。第二次继续从根部开始，查找全部对象，对于没有标记的对象直接释放其所持有的内存
	
    	+	优点：好理解
        +	缺点：如果被引用的对象占所有对象的比例比较小，则需要遍历全部对象，系统消耗较大

*	复制收集

	*	试图解决标记清除带来的问题。另外开辟一块空间，遍历一次，将被引用的对象根据其引用关系存储在新开辟的空间中。然后直接将原空间当做垃圾回收
	
    	+	优点：一定程度上减少了系统开销，对于引用对象比例较低的情况比较适用；同时还有局部性的好处，即相互引用的对象其存储位置也会比较接近，这样提高了访问速度
        +	缺点：对于引用对象比例较高的情况，开辟新的内存空间会比较消耗内存，提高开销

*	引用计数

	*	对于所有对象，按照其被引用的次数进行计数。当引用失效时，就实时减少其对应的引用数；反之亦然。

		+	优点：实现更加容易；更动态，细粒度；由于释放机制是针对个别来实现的，所以中断由GC产生的中断时间更短
        +	缺点：无法应对循环引用；依赖于计数，如果计数出现错误，则很难发现；多线程情况下可能会出现一致性问题

**三种垃圾收集器**

*	串行收集器：单线程，适用数据量较小的情况
*	并行收集器：对吞吐量有要求的大中型应用，响应时间可能比较ch
*	并发收集器：对响应速度有要求的大中型应用