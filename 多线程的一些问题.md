****摘自博客园****

#### 1.	多线程有什么用

提高CPU利用率
防止阻塞的发生，单线程情况下若一个线程阻塞 则整个系统都就阻塞了
便于任务的分节，更加高效

#### 2.	创建线程的方式

继承Thread类，或者实现Runnable接口
后者的效率更高，可以降低耦合度，面向接口编程

#### 3.	start（）和run（）的区别

start是启动线程，run是执行线程的内容，只有start之后，参会表现出多线程的特性。只调用run方法，线程还是同步执行的

#### 4.	Runnable接口和Callable接口的区别

Runnable接口没有返回值,只是单纯执行run（）方法的内容
Callable接口有返回值，返回一个泛型（Future对象），与Future和Futuretask配合可以实现异步执行的结果

#### 5.	CyclicBarrier和CountDownLatch的区别

*	前者设置了一个屏障，只有达到屏障的线程达到一定数量，才一起执行；后者只是将计数器减一，线程还是执行

*	前者可以重复使用，后者只能使用一次

*	前者只能唤起一个任务，后者可以唤起多个任务

#### 6.	volatile关键字的作用

*	保证了操作的可见性,即每个线程见到的volatile变量是一致的，都是最新的数据

*	volatile可以禁止CPU的指令重排序，从而是线程更加安全，但是也会降低代码执行效率

*	volatile与CAS操作结合可以实现操作的原子性

#### 7.什么是线程安全

代码在单线程和多线程情况下执行的结果相同，则是线程安全的

线程安全分为四个等级：

1.	不可变（基本数据类型）
2.	绝对线程安全（很少）
3.	相对线程安全（Concurrent包）
4.	不安全（hashmap ArrayList等）

#### 8.	Java中如何获取到线程dump文件

线程dump指的是线程堆栈

~~~java
Thread.getStackTrace();//获取具体线程的堆栈信息
kill -3 pid//Linux下打印线程堆栈
~~~

#### 9.	一个线程如果出现了运行时异常会怎么样

无法继续执行，若其持有某个对象的监视器，则会释放监视器。

#### 10. 如何在两个线程之间共享数据

通过在线程间共享对象，使用wait、notify唤醒线程

#### 11. sleep方法和wait方法有什么区别

若线程持有对象监视器的话

*	sleep方法是Thread类下的，sleep单独使用，sleep一般不会放弃对象监视器
*	wait方法是Object类下的，wait一般与notify配合使用，wait会放弃对象监视器

#### 12. 生产者消费者模型的作用是什么

通知，等待模式，能够边生产，边消费
**平衡生产者的生产能力和消费者的消费能力，提高整个系统的运行效率**

#### 13. ThreadLocal有什么用

空间换时间，Thread中维护了一个ThreadLocal.ThreadLocalHashMap,对数据进行隔离

#### 14. 为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用

JDK规定，两者在运行前都需要获取对象的锁

#### 15. wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别

*	wait（）方法立即释放监视器
*	notifyAll（）方法等待线程的剩余代码执行完了才释放监视器

#### 16. 为什么要使用线程池

*	可以省去线程，销毁创建的时间，降低系统开销
*	可以灵活地控制并发线程的数量

#### 17. 怎么检测一个线程是否持有对象监视器

Thread类下的holdslock（Object obj）方法，仅当当前线程持有对象监视器时返回true

#### 18. synchronized和ReentrantLock的区别

*	synchronized是关键字，隐式重入
*	ReentrantLock是类，更加灵活，通过多次调用Lock（）方法，显式重入

#### 19. ConcurrentHashMap的并发度是什么

Segment的大小，默认为16，即有16个段。同时可以有是16个线程对hashmap进行操作

#### 20. ReadWriteLock是什么

针对ReentrantLock在面对读写情况时的繁琐，因为在多读的时候，由于读操作不会改变数据，所以不需要加锁。而这时ReentrantLock加锁了，这会降低系统的效率。因此通过ReentrantReadWriteLock（ReadWriteLock的一个具体实现）实现读共享，写互斥。

使用int型的高16位实现读，低16位实现写
通常读操作多于写操作，读写锁的优先级高于排他锁，提高了系统的吞吐量和

21、FutureTask是什么


22、Linux环境下如何查找哪个线程使用CPU最长

23、Java编程写一个会导致死锁的程序

24、怎么唤醒一个阻塞的线程

25、不可变对象对多线程有什么帮助

26、什么是多线程的上下文切换

27、如果你提交任务时，线程池队列已满，这时会发生什么


28、Java中用到的线程调度算法是什么


29、Thread.sleep(0)的作用是什么


30、什么是自旋


31、什么是Java内存模型


32、什么是CAS

33、什么是乐观锁和悲观锁


34、什么是AQS

35、单例模式的线程安全性

36、Semaphore有什么作用

37、Hashtable的size()方法中明明只有一条语句"return count"，为什么还要做同步？


38、线程类的构造方法、静态块是被哪个线程调用的

39、同步方法和同步块，哪个是更好的选择

40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？

