

[TOC]



## 面向对象

1.	创建对象
2.	让对象做事

特征：封装，继承，多态

封装：把数据和对数据的操作放在一起
成员变量：就是java中的属性（例如鸟类所具有的特点（属性），爪子，翅膀，羽毛等）
在函数中可以直接写成员变量的名字来访问成员变量

多态变量：

*	java的对象变量时多态的，它们能保存不止一种类型的对象
*	它们可以保存的是声明类型的对象，或声明类型的子类的对象
*	当把子类的对象赋给父类的变量的时候，就发生了向上造型

### 方法（函数）

返回值：使用return关键字

参数：

*	值参数
*	引用参数（比如数组）
*	不定长参数

形参&&实参以及传值调用&&传引用调用
*	基本数据类型的调用是传值调用
*	对象引用类型的调用是传引用

传值调用时，改变的是形参的值，实参的值不变。实参的值可以传递给形参，反过来不成立
传引用调用时，如果参数是对象，则实参对象的引用一直不变，若改变了对象的值，则会改变实参对象的内容

#### 函数调用的绑定

当通过对象变量调用函数的时候，调用哪个函数这件事情就叫做绑定

*	静态绑定：根据变量的声明类型来绑定
*	动态绑定：根据变量的动态类型来绑定

在成员函数中调用其他成员函数也是通过this这个对象变量来调用的

1.	参数可以有多个，不限类型
2.	每个参数都必须声明参数类型
3.	调用方法时，注意参数顺序

成员方法：就是类的行为

### 构造方法

**构造器（构造方法，构造函数）：是一个类里用于建立对象的特殊子程序。 它能初始化一个新建的对象，并时常会接受参数用以设定实例变量。**

是一个与类重名的方法，对象的创建就是通过构造方法完成的，可以用来进行类的初始化操作

*	构造方法名与类名相同
*	构造方法没有返回值

#### 构造方法和成员方法的区别

格式区别| 构造方法和类名相同，并且没有返回类型，也没有返回值| 普通成员方法可以任意起名，必须有返回类型，可以没有返回值
--|--|--
作用区别|构造方法用于创建对象，并初始化值|普通成员方法用于完成特定功能
调用区别|构造方法在创建对象时调用，一个对象的建立只调用一次构造方法|成员方法由创建好的对象调用，可以多次调用

#### 私有构造方法

* 使用private修饰
* 无法用new实例化

#### 局部变量

在成员方法内定义的变量，区别于类中定义的全局变量（使用时必须初始化）
不同区域内可以存在同名的局部变量

***

==public static void main(String args[])什么意思？==



>　public static void main(String[] args)

>　　这绝对不是凭空想出来的，也不是没有道理的死规定，而是java程序执行的需要。

>　jvm在试图运行一个类之前，先检查该类是否包含一个特殊方法。这个方法必须是公有的，以便在任何位置都能访问得到。这个方法必须是static的，因为这个方法不能依赖任何该类的实例即可运行，而非static的方法，在运行之前要先创建该类的实例对象。

>　　这个方法没有返回值。和C/C++程序不一样，java的程序默认都以常态结束，所以main不返回int。如果要以非常态结束程序，可以用System.exit(1)

>　　这个方法必须可以接受数目不定的String类型的参数，因为运行者可能要附加运行参数。如java HelloWorld jack 100，这里的jack和100就是运行参数

>　　为什么是String呢？因为String具有普遍性。任何字面形式都可以解释成String，而其他类型则不然（如jack就不能解释成整数或浮点数），所以用String来存储参数最合适。而因为参数数目不限一个，所以用了数组，即String[]。在Java 1.5以后，还可以写成String...，表示数目不定。

>　　至于参数的变量名可以任意，只要保证在方法内部按该变量名来获得参数就行了，从变量的作用角度来说，叫arguments或args当然是最合适的。

>　　至于这个方法的名字为什么一定是main，有历史原因，因为最早的C以main函数作为程序入口，java沿用了这个历史传统。

***

### 对象的创建

使用new关键字调用构造方法创建，特例是string对象可以之间创建

对象的类成员

*	属性
*	方法

通过对象.类成员的方式调用

### 对象的销毁

垃圾回收机制
两种对象消亡机制（只能回收new创建的）

~~~java
{
	Example e = new Example();
}//局部程序结束，自动销毁
{
	Example e = new Example();
    e=null;//对象被置为null，就被销毁
}
~~~

finalize()方法
System.gc()强制启动垃圾回收器

匿名对象：没有任何栈内存使用，所以使用一次之后就等待被牢记收集机制回收

~~~java
//主方法之中
new 类(参数1，参数2，……).方法()
~~~

### this关键字

代表类的本身，相当于类本身的一个对象

*	表示类中的属性（为类的属性赋值）
*	调用构造方法

~~~java
    this()//放在构造方法的第一行
~~~

*	表示当前对象

### 类的主方法

类的入口点，定义了程序从何处开始

~~~java
public static void main(String[] args){
}
~~~

*	静态
*	无返回值
*	参数是数组

主方法相当于是大门，通过它才能调用其他方法

##	类的封装

以类为载体进行封装

### 封装的思想

将对象的属性和行为封装起来，而将对象的属性和行为封装起来的载体就是累，类通常对客户隐藏其实现细节，只能通过具体的对象访问类的属性和行为

## 类的继承

### extends关键字

~~~java
Child extends Father;
//例如
public class Pad extends Computer{
……
}
~~~

存在继承的情况下，初始化顺序为：

1.	父类（静态变量、静态语句块）
2.	子类（静态变量、静态语句块）
3.	父类（实例变量、普通语句块）
4.	父类（构造函数）
5.	子类（实例变量、普通语句块）
6.	子类（构造函数）

## 方法的重写

### super关键字

代表父类的对象
~~~java
super.pwer()
super.ass
~~~

*	调用父类的构造方法
*	调用父类的属性
*	调用父类的方法

*java中，一个类只允许有一个父类



要想实现继承多个父类，需要使用多重继承的方法*



~~~java



public class Parent1 extends Parent2;



public class son extends Parent1;



~~~



*子类不仅会覆盖父类的方法，还会覆盖父类的属性*

## 方法的重载

*	一个类可以有多个构造函数，只要它们的参数表不同
*	创建对象的时候给出不同的参数值，就会调用不同的构造函数
*	通过this()还可以调用其他构造函数
*	一个类里的同名但参数表不同的函数构成了重载关系

怎样构成方法的重载

*	方法名相同参数不同
*	方法名相同，参数顺序不同
*	方法名相同，参数类型不同

*在String的API文档中，string的定义利用了方法重载，将不同类型的方法转换为字符串*

## object类

是类层次结构的根类
object类的三个方法

*	getClass():返回对象执行时的Class实例
*	toString():将对象返回为字符串形式
*	equal()；比较两个对象是否相等（地址是否相等）

### 类的上下转型（造型cast）

*	 类的向上转型（父类声明一个对象，由子类进行实例化）
	*	 ~~~java
		 Father a =new Child;
		 ~~~

*	 类的向下转型
	*	~~~java
		Parents P=new Parents();
        Child c=(Child)p;//强制将父类对象转化为子类对象
		~~~

++造型不同于类型转换：对象本身并没有发生任何变化++
向上造型：拿一个子类的对象当做父类的对象来用；向上造型是默认的，不需要运算符；向上造型总是安全的

### instanceof关键字

~~~java
boolean result =child instanceof parents//判断子类是否继承自父类，两个没有继承关系的类会直接报错
~~~
