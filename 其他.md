
[TOC]



### B树

文件系统的索引和存储一般都在硬盘上，如果数据量大的话，可能无法一次性加载到内存。通过B树的多路存储，可以一次加载树中的一个节点（比如三路存储，一个节点最多有两个数）

在内存中，红黑树的效率高于B树
但是涉及到硬盘操作时，B树的效率更高

B+树是B树的优化，所有数据都在叶子节点；原因在于，在数据库索引的时候，可能需要进行局部的遍历，这时由于B+树的所有数据都在叶子节点，且有链表相连，所以遍历起来不用跨层

### getinstance

创建一个对象，与new没什么区别。但是如果构造方法被私有化，则无法使用new

### hash函数

Hash代表一类函数，即把任意范围的函数通过映射关系压缩成固定范围的函数

Hash函数该选择什么样的函数：
必须要使经过Hash函数的关键字尽可能的均匀分布
不同数据类型的关键字要有自己的hash函数

产生的冲突该如何解决：
链表法存在的问题是，当所需存储的值远远大于数组长度时，链表的长度也不可避免的过度增加

这个时候需要rehash，就是将数组的长度增加。这里一般是增加一倍之后最大的素数
而什么时候增加，就取决于装填因子，一般情况下选取0.75。同时，装填因子是可能大于1的，比如链表处理冲突的情况，就很容易大于1

### null&isEmpty

null表示未分配内存，值不存在
isEmpty()可以理解为分配了内存但是没有内容，相当于空字符串

### RMI

远程方法调用，能让java虚拟机像调用一个本队对象一样调用另一个java虚拟机中对象上的方法

大大增强了java分布式开发的能力，例如可将计算方法复杂的的程序放在其他服务器上，主服务器只管调用。这样可以节省很多开销

### RT&QPS

RT（response time）:响应时间，指的是从客户端向服务器发送消息开始算起，到收到服务器的响应为止的时间

QPS（query per second）：系统每秒能处理的请求数，也称为吞吐量

RT=并发数/QPS
QPS=并发数/RT

可通过提高cpu利用率，增加cpu核数，提升内存等方式提高QPS

并发用户数：同一时刻与系统发生交互的在线用户数

最佳线程数：能够保证系统内存占用率和cpu负载率等出现大幅度增加的QPS阈值

### select&poll&epoll

都是IO多路复用机制（就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪，可以通知程序进行相应的读写操作）。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的

### String&StringBuilder&StringBuffer

String的实现其实是Char value[]。比如一个字符串“ajsdf”的实际存储是：char[] value=‘A’‘j’‘s’‘d’‘f’。同时，这个value是加了final修饰符的，所以可认为String是不可变的。而通过‘+’对String进行增加，其实是使用StringBuilder的append方法之后，再使用toString()方法实现的

StringBuffer是线程安全的可变字符序列。StringBuffer在添加字符序列的时候，使用append方法，这里使用的是synchronized关键字，表明是线程安全的。同时使用的是return this返回，这表示返回的是当前stringbuffer的值，而不是像String一样new一个String。另外，append方法的具体实现是在父类中定义的，这里只是调用父类的方法
StringBuffer的主要方法有append（）和insert（），可以重载这两个方法，实现将任意类型的数据转换为字符串，插入到指定的位置或者直接拼接到末尾


StringBuilder是对StringBuffer的补足，应用于单线程的情况下（线程不安全）。区别仅在于StringBuilder的append方法没有使用Synchronized修饰符修饰


总结：
少量数据操作，使用String
单线程大量数据操作，使用StringBuilder
多线程大量数据操作，使用StringBuffer

StringBuilder对于字符串的拼接操作时，最好在线程内部完成（因为线程不安全）

### 抽象类&抽象方法

抽象类

1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。

2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

4. 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。

5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

抽象方法

抽象方法没有方法体，必须有其所在的抽象类的子类继承来实现

### 动态规划&递归&贪心算法

意义在于通过采用递归（分而治之）的策略，通过解决大问题的子问题从而解决问题的做法。
核心思想在于将大问题拆分为多个子问题，通过计算子问题而得到整体问题的解。而子问题又可以拆分成更多的子问题，从而用类似递推迭代的方法解决要求的问题

动态规划解题核心（状态转移的思路）
第一步：状态的定义
第二步：状态转移方程的定义

动态规划的应用场景
对于一个可拆分问题中存在可以由前若干项计算当前项的问题可以用动态规划来计算
存在一种递推的连带关系

递归算法是一个自底向上的过程，小问题的结果层层返回，最后得到大问题的结果

贪心算法是动态规划问题中的局部最优解，不需要遍历子问题中的所有情况，一般只取当前最优情况

### 对称&非对称加密（SSL加密协议）

意义在于通过采用递归（分而治之）的策略，通过解决大问题的子问题从而解决问题的做法。
核心思想在于将大问题拆分为多个子问题，通过计算子问题而得到整体问题的解。而子问题又可以拆分成更多的子问题，从而用类似递推迭代的方法解决要求的问题

动态规划解题核心（状态转移的思路）
第一步：状态的定义
第二步：状态转移方程的定义

动态规划的应用场景
对于一个可拆分问题中存在可以由前若干项计算当前项的问题可以用动态规划来计算
存在一种递推的连带关系

递归算法是一个自底向上的过程，小问题的结果层层返回，最后得到大问题的结果

贪心算法是动态规划问题中的局部最优解，不需要遍历子问题中的所有情况，一般只取当前最优情况

### 反向代理&正向代理

反向代理:内部网络的服务器不能直接与外部网络相连接，需要一个代理服务器。代理服务器接受外部Internet上的访问请求，并将其转发给内部服务器，同时返回内部服务器对其的响应结果。这个代理服务器和内部服务器处于同一个网络中，甚至可能是同一个服务器，只是端口不同。反向代理不需要客户端进行任何设置

正向代理：是一个位于客户端和服务器端之间代理服务器。客户端为了从服务器端获取内容，就要向反向代理服务器发送请求。并指定目标服务器端口号。正向代理需要客户端设置设置服务器ip或者域名

### 树的平衡性

反向代理:内部网络的服务器不能直接与外部网络相连接，需要一个代理服务器。代理服务器接受外部Internet上的访问请求，并将其转发给内部服务器，同时返回内部服务器对其的响应结果。这个代理服务器和内部服务器处于同一个网络中，甚至可能是同一个服务器，只是端口不同。反向代理不需要客户端进行任何设置

正向代理：是一个位于客户端和服务器端之间代理服务器。客户端为了从服务器端获取内容，就要向反向代理服务器发送请求。并指定目标服务器端口号。正向代理需要客户端设置设置服务器ip或者域名

### DNS劫持&DNS投毒

##### DNS劫持

是指客户端向DNS服务器发送请求，DNS服务器返回一个错误的域名IP地址，将客户端访问结果导向其他网址

##### DNS投毒

是指客户端向dns服务器发送请求，在等待服务器返回响应的过程中，这时黑客或者其他第三方伪造了DNS响应，返回了错误的IP地址。

### UML

UML是统一建模语言（UML是 Unified Modeling Language的缩写）是用来对软件密集系统进行可视化建模的一种语言。UML为面向对象开发系统的产品进行说明、可视化、和编制文档的一种标准语言。
统一建模语言 (UML)是非专利的第三代建模和规约语言。 UML是在开发阶段，说明，可视化，构建和书写一个面向对象软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面,特别是在软件架构层次已经被验证有效。
UML可以贯穿软件开发周期中的每一个阶段。被OMG采纳作为业界的标准。
UML最适于数据建模，业务建模，对象建模，组件建模。
UML作为一种模型语言，它使开发人员专注于建立产品的模型和结构，而不是选用什么程序语言和算法实现。当模型建立之后，模型可以被UML工具转化成指定的程序语言代码。
IBM的Rational Rose和MS的Visio都是UML工具。